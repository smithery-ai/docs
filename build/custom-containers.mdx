---
title: "Building Custom Containers"
description: "Learn how to build MCP servers using custom Docker containers for maximum flexibility and control."
---

Building MCP servers with custom containers gives you complete control over your environment, dependencies, and runtime configuration. This approach is ideal when you need:

- Non-Node.js languages (Python, Go, Rust, etc.)
- System-level dependencies
- Custom middleware or authentication
- Specialized database drivers
- Multi-stage builds or complex build processes

## Prerequisites

- Docker installed locally
- Basic understanding of Dockerfile syntax
- Your MCP server code ready

## Project Structure

A typical custom container MCP project looks like this:

```
my-mcp-server/
├── Dockerfile
├── smithery.yaml
├── src/
│   ├── main.py          # Your MCP server code
│   └── requirements.txt # Dependencies
└── README.md
```

## Creating Your Dockerfile

Your Dockerfile must expose your MCP server on port `8000` using HTTP transport. Here are examples for different languages:

<Tabs>
<Tab title="Python">
```dockerfile
FROM python:3.11-slim

WORKDIR /app

# Copy requirements and install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy source code
COPY src/ ./src/

# Expose port 8000
EXPOSE 8000

# Start the MCP server
CMD ["python", "-m", "src.main"]
```
</Tab>

<Tab title="Go">
```dockerfile
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o main .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/

COPY --from=builder /app/main .

EXPOSE 8000
CMD ["./main"]
```
</Tab>

<Tab title="Rust">
```dockerfile
FROM rust:1.70 AS builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src/ ./src/

RUN cargo build --release

FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y ca-certificates && rm -rf /var/lib/apt/lists/*

COPY --from=builder /app/target/release/mcp-server /usr/local/bin/mcp-server

EXPOSE 8000
CMD ["mcp-server"]
```
</Tab>

<Tab title="Node.js (Custom)">
```dockerfile
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci --only=production

# Copy source code
COPY src/ ./src/

# Expose port 8000
EXPOSE 8000

# Start the server
CMD ["node", "src/index.js"]
```
</Tab>
</Tabs>

## HTTP Transport Implementation

Your MCP server must implement the [Streamable HTTP transport](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#streamable-http). Here's what this means:

### Key Requirements

1. **Listen on port 8000**
2. **Accept POST requests** at the root path (`/`)
3. **Handle JSON-RPC messages** in the request body
4. **Return JSON-RPC responses** with proper content-type headers

### Example Implementation

<Tabs>
<Tab title="Python (FastAPI)">
```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import json

app = FastAPI()

@app.post("/")
async def handle_mcp_request(request: Request):
    """Handle MCP JSON-RPC requests"""
    body = await request.json()
    
    # Process the MCP request
    response = process_mcp_request(body)
    
    return JSONResponse(
        content=response,
        headers={"Content-Type": "application/json"}
    )

def process_mcp_request(request_data):
    """Process MCP JSON-RPC request and return response"""
    method = request_data.get("method")
    params = request_data.get("params", {})
    request_id = request_data.get("id")
    
    # Handle different MCP methods
    if method == "initialize":
        return {
            "jsonrpc": "2.0",
            "id": request_id,
            "result": {
                "protocolVersion": "2025-03-26",
                "capabilities": {
                    "tools": {}
                },
                "serverInfo": {
                    "name": "my-custom-server",
                    "version": "1.0.0"
                }
            }
        }
    
    # Add more method handlers...
    
    return {
        "jsonrpc": "2.0",
        "id": request_id,
        "error": {
            "code": -32601,
            "message": "Method not found"
        }
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```
</Tab>

<Tab title="Go (net/http)">
```go
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
)

type JSONRPCRequest struct {
    JSONRPC string      `json:"jsonrpc"`
    Method  string      `json:"method"`
    Params  interface{} `json:"params,omitempty"`
    ID      interface{} `json:"id,omitempty"`
}

type JSONRPCResponse struct {
    JSONRPC string      `json:"jsonrpc"`
    Result  interface{} `json:"result,omitempty"`
    Error   interface{} `json:"error,omitempty"`
    ID      interface{} `json:"id,omitempty"`
}

func handleMCP(w http.ResponseWriter, r *http.Request) {
    if r.Method != "POST" {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }
    
    var req JSONRPCRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    
    var resp JSONRPCResponse
    resp.JSONRPC = "2.0"
    resp.ID = req.ID
    
    switch req.Method {
    case "initialize":
        resp.Result = map[string]interface{}{
            "protocolVersion": "2025-03-26",
            "capabilities": map[string]interface{}{
                "tools": map[string]interface{}{},
            },
            "serverInfo": map[string]interface{}{
                "name":    "my-custom-server",
                "version": "1.0.0",
            },
        }
    default:
        resp.Error = map[string]interface{}{
            "code":    -32601,
            "message": "Method not found",
        }
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(resp)
}

func main() {
    http.HandleFunc("/", handleMCP)
    log.Println("Server starting on port 8000...")
    log.Fatal(http.ListenAndServe(":8000", nil))
}
```
</Tab>
</Tabs>

## Configuration with smithery.yaml

Create a `smithery.yaml` file to configure your server:

```yaml
name: "My Custom MCP Server"
description: "A custom MCP server built with Docker"
author: "Your Name"
license: "MIT"

# Deployment configuration
deployment:
  type: "custom-container"
  
# Server capabilities
capabilities:
  tools: true
  resources: false
  prompts: true

# Tool definitions (optional, for documentation)
tools:
  - name: "example_tool"
    description: "An example tool"
    parameters:
      type: "object"
      properties:
        input:
          type: "string"
          description: "Input parameter"
```

## Testing Locally

Before deploying, test your container locally:

1. **Build the container:**
   ```bash
   docker build -t my-mcp-server .
   ```

2. **Run the container:**
   ```bash
   docker run -p 8000:8000 my-mcp-server
   ```

3. **Test the MCP endpoint:**
   ```bash
   curl -X POST http://localhost:8000 \
     -H "Content-Type: application/json" \
     -d '{
       "jsonrpc": "2.0",
       "method": "initialize",
       "params": {},
       "id": 1
     }'
   ```

## Common Patterns

### Environment Variables

Use environment variables for configuration:

```dockerfile
# In Dockerfile
ENV MCP_SERVER_NAME="my-server"
ENV MCP_SERVER_VERSION="1.0.0"
```

```python
# In Python code
import os

server_name = os.getenv("MCP_SERVER_NAME", "default-server")
```

### Health Checks

Add health check endpoints:

```python
@app.get("/health")
async def health_check():
    return {"status": "healthy"}
```

### Logging

Implement proper logging for debugging:

```python
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@app.post("/")
async def handle_mcp_request(request: Request):
    body = await request.json()
    logger.info(f"Received MCP request: {body.get('method')}")
    # ... rest of handler
```

## Best Practices

### Security
- Don't run as root user in production
- Use multi-stage builds to reduce image size
- Scan images for vulnerabilities
- Use specific base image tags (not `latest`)

### Performance
- Use `.dockerignore` to exclude unnecessary files
- Leverage Docker layer caching
- Minimize the number of RUN commands
- Use Alpine Linux for smaller images

### Development
- Use volume mounts for local development
- Implement graceful shutdown handling
- Add comprehensive error handling
- Include request/response validation

## Example .dockerignore

```dockerignore
node_modules/
.git/
.gitignore
README.md
Dockerfile
.dockerignore
*.log
.env
.env.local
coverage/
.nyc_output/
```

## Deployment

Once your custom container is ready:

1. Push your code to a Git repository
2. Connect your repository to Smithery
3. Smithery will automatically build and deploy your container
4. Your MCP server will be available at your Smithery URL

## Troubleshooting

### Common Issues

**Container fails to start:**
- Check that your server listens on `0.0.0.0:8000`, not `localhost:8000`
- Ensure your Dockerfile exposes port 8000
- Verify your startup command is correct

**MCP requests fail:**
- Confirm you're handling POST requests at the root path
- Check that you're returning proper JSON-RPC responses
- Validate your JSON-RPC message format

**Build failures:**
- Review your Dockerfile syntax
- Check that all dependencies are available
- Ensure file paths are correct

### Debugging

Enable verbose logging and check the deployment logs in your Smithery dashboard for detailed error information.

## Next Steps

- [Deploy your custom container](/build/deployments/custom-container)
- [Configure project settings](/build/project-config)
- [Set up permissions](/build/permissions)
- [Learn about MCP concepts](/concepts/what_is_mcp)
