---
title: 'Session Configuration'
description: 'Allow clients to connect to MCP servers with a specific configuration.'
---

Session configurations let you give your users flexibility in how your MCP server behaves for their specific connection. Each user can customize their session differently, and configurations provide a secure way for them to pass secrets (e.g., API keys) to your server.

## How Configurations Work

Every MCP server can define what configuration parameters it accepts. These parameters might include API keys, model settings, temperature values, or any other options that affect how the server responds to requests.

<Info>
  Configurations are bound to individual sessions. Each client connection has its own configuration that doesn't affect other sessions.
</Info>

## Define Your Configuration Schema

Define what configuration your MCP server needs using JSON Schema in your [`smithery.yaml`](/build/project-config/smithery-yaml) file:

```yaml smithery.yaml
startCommand:
    type: http
    configSchema:
      type: object
      required: ["openaiApiKey"]
      properties:
        openaiApiKey:
          type: string
          title: "OpenAI API Key"
          description: "Your OpenAI API key"
        modelName:
          type: string
          title: "Model Name"
          default: "gpt-4"
          enum: ["gpt-3.5-turbo", "gpt-4", "gpt-4-turbo"]
        temperature:
          type: number
          title: "Temperature"
          description: "Controls randomness of output"
          default: 0.7
          minimum: 0
          maximum: 1
```

The `configSchema` supports all standard JSON Schema features:
- Data types (`string`, `number`, `boolean`, etc.)
- Required fields
- Default values
- Enumerated options
- Min/max constraints
- Descriptive titles and documentation

The schema is used to both validate configurations and generate user interfaces in the Smithery web app.

## How Your Server Receives Configuration

**Your MCP server receives configuration as a base64-encoded JSON object** in the `config` query parameter:

```
GET/POST /mcp?config=eyJzZXJ2ZXIiOnsiaG9zdCI6ImxvY2FsaG9zdCIsInBvcnQiOjgwODB9LCJkZWJ1ZyI6dHJ1ZX0=
```

To parse this configuration in your server:

<CodeGroup>

```typescript TypeScript
// Parse configuration from query parameters
function parseConfig(req: Request) {
  const url = new URL(req.url);
  const configParam = url.searchParams.get('config');
  if (configParam) {
    return JSON.parse(Buffer.from(configParam, 'base64').toString());
  }
  return {};
}

// Usage in your MCP tool
const config = parseConfig(request);
const dbUrl = config.connectionString;
const maxResults = config.maxResults || 10;

// Each session connects to their own database
```

```python Python
import json
import base64
from urllib.parse import parse_qs, urlparse

def parse_config(request_url: str) -> dict:
    """Parse base64-encoded config from query parameters."""
    parsed_url = urlparse(request_url)
    params = parse_qs(parsed_url.query)
    
    if 'config' in params:
        config_b64 = params['config'][0]
        config_json = base64.b64decode(config_b64).decode('utf-8')
        return json.loads(config_json)
    
    return {}

# Usage
config = parse_config(request.url)
print(config)  # {'server': {'host': 'localhost', 'port': 8080}, 'debug': True}
```

</CodeGroup>

### Using Configuration in Your Server

Once you've parsed the configuration, you can use these values throughout your MCP server:

<CodeGroup>

```typescript TypeScript
// Example: Using config in an MCP tool
server.registerTool("query_database", {
  description: "Query the database with user's connection",
  inputSchema: {
    query: { type: "string", description: "SQL query to execute" }
  }
}, async ({ query }, { request }) => {
  const config = parseConfig(request);
  
  // Use configuration values
  const dbUrl = config.connectionString;
  const maxResults = config.maxResults || 10;
  const apiKey = config.openaiApiKey;
  
  // Connect to user's specific database
  const connection = await connectToDatabase(dbUrl);
  const results = await connection.query(query, { limit: maxResults });
  
  return {
    content: [{ type: "text", text: JSON.stringify(results) }]
  };
});
```

```python Python
@mcp.tool()
def query_database(query: str) -> str:
    """Query the database with user's connection"""
    # Access the parsed config (stored globally or passed to tool)
    db_url = current_config.get('connectionString')
    max_results = current_config.get('maxResults', 10)
    api_key = current_config.get('openaiApiKey')
    
    # Use configuration values in your tool logic
    connection = connect_to_database(db_url)
    results = connection.query(query, limit=max_results)
    
    return json.dumps(results)
```

</CodeGroup>



## Examples

### Minimal Configuration

If your server doesn't need any configuration, you can use an empty schema:

```yaml smithery.yaml
  startCommand:
    type: http
    configSchema: {}
```

### Database Connection Configuration

A database connector might require connection details:

```yaml smithery.yaml
  startCommand:
    type: http
    configSchema:
      type: object
      required: ["connectionString"]
      properties:
        connectionString:
          type: string
          title: "Connection String"
          description: "Database connection string"
        maxConnections:
          type: integer
          default: 5
          minimum: 1
          maximum: 20
        debug:
          type: boolean
          default: false
```

## Best Practices for MCP Authors

1. **Provide clear documentation**
   - Use `description` fields in your schema
   - Document any non-obvious parameters

2. **Set sensible defaults**
   - Users should be able to connect with minimal configuration
   - Use the `default` property for optional parameters

3. **Use enums for limited choices**
   - When there are specific valid options, list them in an `enum`
   - This creates a dropdown in the UI instead of a free text field

4. **Handle configuration securely**
   - Pass secrets as environment variables
   - Never log or expose configuration values
   - Validate input server-side even though Smithery performs validation

5. **Keep configurations small**
   - Focus on essential parameters
   - Large binary data should not be passed via configuration

## Troubleshooting

### What happens if my configuration is invalid?

If a configuration doesn't match the schema, Smithery will reject the connection attempt and provide an error message explaining what's wrong.

### Can I change configuration mid-session?

No, configurations are bound to a session at connection time and cannot be changed during the session. To use a different configuration, establish a new connection.

### Can configurations be optional?

Yes, by not including fields in the `required` array of your schema, those fields become optional. You can also provide default values using the `default` property.

### Where can I find a server's configuration schema?

You can view any MCP server's configuration schema in its API Tab on the server page. It provides a clean, syntax-highlighted code block of the raw JSON schema for easy reference and copying.

## See Also

- [Project Configuration](/build/project-config) - How to define server configuration in `smithery.yaml`
- [JSON Schema Documentation](https://json-schema.org/understanding-json-schema/) - Learn more about JSON Schema
