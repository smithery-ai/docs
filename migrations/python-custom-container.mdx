---
title: "Python Custom Container"
description: "Migrate your Python MCP servers to Streamable HTTP, with STDIO support for backwards cimpatibility"
---

## When to Use This Approach

Choose Python custom containers when you:
- Prefer to use Python for your MCP server
- Need full control over your Docker environment
- Want to use FastMCP with custom middleware
- Have specific Python dependencies or requirements

<Card
  title="Show me the repo"
  icon="github"
  href="https://github.com/smithery-ai/smithery-cookbook/tree/main/servers/python/migrate_stdio_to_http"
>
  View the fully runnable GitHub repo for this example
</Card>

## What We're Building

We'll build a simple MCP server with a `count_characters` tool that:
- Counts occurrences of a specific character in text
- Demonstrates per-request configuration access (server token, user preferences)
- Extracts and validates Smithery session configuration - [see session config docs](https://smithery.ai/docs/build/session-config) for more details
- Shows proper CORS handling and middleware setup
- Supports both HTTP and STDIO transport

## Code Migration

<Info>
**Already have HTTP support?** If your MCP server already supports HTTP transport, you can skip ahead to Step 5: Update smithery.yaml to configure your deployment settings.
</Info>

### Let's say you start with this...

Here's a typical STDIO-based MCP server that you might be starting with:

```python
# src/main.py
import os
from mcp.server.fastmcp import FastMCP
from typing import Optional

# Create STDIO server
mcp = FastMCP("Character Counter")

# Get configuration from environment variables
server_token = os.getenv("SERVER_TOKEN")
max_length = int(os.getenv("MAX_TEXT_LENGTH", "1000"))

def validate_server_access(server_token: Optional[str]) -> bool:
    """Validate server token - accepts any string including empty ones for demo."""
    # In a real app, you'd validate against your server's auth system
    # For demo purposes, we accept any non-empty token
    return server_token is not None and len(server_token.strip()) > 0 if server_token else True

@mcp.tool()
def count_characters(text: str, character: str) -> str:
    """Count occurrences of a specific character in text"""
    # Validate server access (your custom validation logic)
    if not validate_server_access(server_token):
        raise ValueError("Server access validation failed. Please provide a valid serverToken.")
    
    # Apply user preferences from config
    if len(text) > max_length:
        raise ValueError(f"Text too long. Maximum length is {max_length} characters.")
    
    # Count occurrences
    count = text.lower().count(character.lower())
    
    return f'The character "{character}" appears {count} times in the text.'

# Run with STDIO transport
if __name__ == "__main__":
    mcp.run()
```

### Step 1: Update Imports and Setup

Now let's migrate this to work as an HTTP container. Set up your FastMCP server with the necessary imports:

```python
# src/main.py
import os
import uvicorn
from mcp.server.fastmcp import FastMCP
from starlette.middleware.cors import CORSMiddleware
from typing import Optional
from src.middleware import SmitheryConfigMiddleware

# Initialize MCP server
mcp = FastMCP(name="Character Counter")
```

### Step 2: Configuration Handling (Optional)

<Info>
**Skip this entire step if no configuration needed**: If your MCP server doesn't need any configuration (API keys, settings, etc.), you can skip this entire step including the middleware setup. Your server will work perfectly fine without any configuration handling.
</Info>

If your server needs configuration (like API keys, user preferences, etc.), you'll need both the configuration handling functions and the middleware to extract config from requests.

#### Step 2a: Add Configuration Functions

Add these configuration handling functions to your main.py:

```python
# src/main.py (continued - only add if you need configuration)

def handle_config(config: dict):
    """Handle configuration from Smithery - for backwards compatibility with stdio mode."""
    global _server_token
    if server_token := config.get('serverToken'):
        _server_token = server_token
    # You can handle other session config fields here

# Store server token only for stdio mode (backwards compatibility)
_server_token: Optional[str] = None

def get_request_config() -> dict:
    """Get full config from current request context."""
    try:
        # Access the current request context from FastMCP
        import contextvars
        
        # Try to get from request context if available
        request = contextvars.copy_context().get('request')
        if hasattr(request, 'scope') and request.scope:
            return request.scope.get('smithery_config', {})
    except:
        pass

def get_config_value(key: str, default=None):
    """Get a specific config value from current request."""
    config = get_request_config()
    return config.get(key, default)

def validate_server_access(server_token: Optional[str]) -> bool:
    """Validate server token - accepts any string including empty ones for demo."""
    # In a real app, you'd validate against your server's auth system
    # For demo purposes, we accept any non-empty token
    return server_token is not None and len(server_token.strip()) > 0 if server_token else True
```

#### Step 2b: Create Middleware Setup

Create the middleware for handling Smithery configuration:

```python
# src/middleware.py
import json
import base64
from urllib.parse import parse_qs, unquote

class SmitheryConfigMiddleware:
    def __init__(self, app):
        self.app = app

    async def __call__(self, scope, receive, send):
        if scope.get('type') == 'http':
            query = scope.get('query_string', b'').decode()
            
            if 'config=' in query:
                try:
                    config_b64 = unquote(parse_qs(query)['config'][0])
                    config = json.loads(base64.b64decode(config_b64))
                    
                    # Inject full config into request scope for per-request access
                    scope['smithery_config'] = config
                except Exception as e:
                    print(f"SmitheryConfigMiddleware: Error parsing config: {e}")
                    scope['smithery_config'] = {}
            else:
                scope['smithery_config'] = {}
        
        await self.app(scope, receive, send)
```

This middleware:
- Extracts base64-encoded configuration from URL query parameters
- Decodes and parses the JSON configuration
- Stores the config in the request scope for per-request access
- Provides error handling and logging for debugging

### Step 3: Register Tools

Define your MCP tool:

```python
# src/main.py
# MCP Tool - demonstrates per-request config access
@mcp.tool()
def count_characters(text: str, character: str) -> str:
    """Count occurrences of a specific character in text"""
    # Example: Get various config values that users can pass to your server session
    server_token = get_config_value("serverToken")
    max_length = get_config_value("maxTextLength", 1000)
    
    # Validate server access (your custom validation logic)
    if not validate_server_access(server_token):
        raise ValueError("Server access validation failed. Please provide a valid serverToken.")
    
    # Apply user preferences from config
    if len(text) > max_length:
        raise ValueError(f"Text too long. Maximum length is {max_length} characters.")
    
    # Count occurrences
    count = text.lower().count(character.lower())
    
    return f'The character "{character}" appears {count} times in the text.'
```

### Step 4: Main Function and Server Startup

Handle both HTTP and STDIO transport modes:

```python
# src/main.py
def main():
    transport_mode = os.getenv("TRANSPORT", "stdio")
    
    if transport_mode == "http":
        # HTTP mode with config extraction from URL parameters
        print("Character Counter MCP Server starting in HTTP mode...")
        
        # Setup Starlette app with CORS for cross-origin requests
        app = mcp.streamable_http_app()
        
        # IMPORTANT: add CORS middleware for browser based clients
        app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["GET", "POST", "OPTIONS"],
            allow_headers=["*"],
            expose_headers=["mcp-session-id", "mcp-protocol-version"],
            max_age=86400,
        )

        # Apply custom middleware for config extraction (per-request API key handling)
        app = SmitheryConfigMiddleware(app)

        # Use Smithery-required PORT environment variable
        port = int(os.environ.get("PORT", 8081))
        print(f"Listening on port {port}")

        uvicorn.run(app, host="0.0.0.0", port=port, log_level="debug")
    
    else:
        # Optional: add stdio transport for backwards compatibility
        # You can publish this to uv for users to run locally
        print("Character Counter MCP Server starting in stdio mode...")
        
        server_token = os.getenv("SERVER_TOKEN")
        # Set the server token for stdio mode (can be None)
        handle_config({"serverToken": server_token})
        
        # Run with stdio transport (default)
        mcp.run()

if __name__ == "__main__":
    main()
```

<Note>
**How it works**: When you deploy with custom containers, your FastMCP server handles HTTP requests directly through the streamable HTTP app. The `main()` function only runs STDIO mode when you execute the file directly (like `python src/main.py`), giving you STDIO support for local development and backward compatibility.
</Note>

## Configuration Changes

### Step 5: Update smithery.yaml

<CodeGroup>

```yaml Before (STDIO)
# smithery.yaml
startCommand:
  type: stdio
  commandFunction: |
    (config) => ({
      command: 'python',
      args: ['server.py'],
      env: {
        SERVER_TOKEN: config.serverToken,
        MAX_TEXT_LENGTH: config.maxTextLength
      }
    })
  configSchema:
    type: object
    required: [serverToken]
    properties:
      serverToken:
        type: string
        description: Your server token
      maxTextLength:
        type: integer
        description: Maximum allowed text length
        default: 1000
  exampleConfig:
    serverToken: "token-123"
    maxTextLength: 1000
```

```yaml After (HTTP Container)
# smithery.yaml
runtime: "container"
build:
  dockerfile: "Dockerfile"           # Path to your Dockerfile
  dockerBuildPath: "."               # Docker build context
startCommand:
  type: "http"
  # configSchema and exampleConfig are optional - remove if no configuration needed
  configSchema:                      # Optional: Define configuration schema
    type: object
    required: [serverToken]
    properties:
      serverToken:
        type: string
        description: Your server token
      maxTextLength:
        type: integer
        description: Maximum allowed text length
        default: 1000
  exampleConfig:                     # Optional: Example configuration
    serverToken: "token-123"
    maxTextLength: 1000
```
</CodeGroup>

### Step 6: Update Dockerfile

You can create your own Dockerfile or use this recommended template:

<CodeGroup>

```dockerfile Before (STDIO)
# Dockerfile
# Use a Python image with uv pre-installed
FROM ghcr.io/astral-sh/uv:python3.12-alpine

# Install the project into `/app`
WORKDIR /app

# Enable bytecode compilation
ENV UV_COMPILE_BYTECODE=1

# Copy from the cache instead of linking since it's a mounted volume
ENV UV_LINK_MODE=copy

# Install the project's dependencies using the lockfile and settings
RUN --mount=type=cache,target=/root/.cache/uv \
    --mount=type=bind,source=uv.lock,target=uv.lock \
    --mount=type=bind,source=pyproject.toml,target=pyproject.toml \
    uv sync --locked --no-install-project --no-dev

# Then, add the rest of the project source code and install it
COPY . /app
RUN --mount=type=cache,target=/root/.cache/uv \
    uv sync --locked --no-dev

# Place executables in the environment at the front of the path
ENV PATH="/app/.venv/bin:$PATH"

# Reset the entrypoint, don't invoke `uv`
ENTRYPOINT []

# STDIO servers don't expose ports
CMD ["python", "src/main.py"]
```

```dockerfile After (HTTP Container)
# Dockerfile
# Use a Python image with uv pre-installed
FROM ghcr.io/astral-sh/uv:python3.12-alpine

# Install the project into `/app`
WORKDIR /app

# Enable bytecode compilation
ENV UV_COMPILE_BYTECODE=1

# Copy from the cache instead of linking since it's a mounted volume
ENV UV_LINK_MODE=copy

# Install the project's dependencies using the lockfile and settings
RUN --mount=type=cache,target=/root/.cache/uv \
    --mount=type=bind,source=uv.lock,target=uv.lock \
    --mount=type=bind,source=pyproject.toml,target=pyproject.toml \
    uv sync --locked --no-install-project --no-dev

# Then, add the rest of the project source code and install it
# Installing separately from its dependencies allows optimal layer caching
COPY . /app
RUN --mount=type=cache,target=/root/.cache/uv \
    uv sync --locked --no-dev

# Place executables in the environment at the front of the path
ENV PATH="/app/.venv/bin:$PATH"

# Set transport mode to HTTP
ENV TRANSPORT=http

# Reset the entrypoint, don't invoke `uv`
ENTRYPOINT []

# Run the application directly using the venv Python
CMD ["python", "src/main.py"]
```

</CodeGroup>

<Note>
**uv Docker Best Practices**: For more examples and best practices on using uv with Docker, including multistage builds and development workflows, check out the [uv Docker example repository](https://github.com/astral-sh/uv-docker-example).
</Note>



## Local Testing

1. **Run directly with Python:**
   ```bash
   # Install dependencies
   uv sync
   
   # Run in HTTP mode
   TRANSPORT=http uv run python src/main.py
   ```

2. **Or with Docker:**
   ```bash
   docker build -t character-counter .
   docker run -p 8081:8081 -e PORT=8081 character-counter
   ```

<Note>
**Local vs Deployed Ports**: For local testing, you can use any port. However, when deployed to Smithery, your server **must** listen on the `PORT` environment variable, which Smithery will set to 8081.
</Note>

3. **Test interactively:**
   Once your server is running in HTTP mode, you can test it interactively using the Smithery playground:
   ```bash
   npx @smithery/cli playground --port 8081
   ```

   <img
     src="/images/smithery_playground.png"
     alt="Smithery Interactive Playground"
     className="rounded-lg shadow-sm"
   />

   <Note>
   **Config Handling Limitation**: The Smithery playground doesn't currently support config handling for custom containers (Python/TypeScript). Your deployed server will support configuration, but local testing with the playground will use default/empty config values. We're actively working on adding this support.
   </Note>

## Deployment

1. **Push Code**: Push your updated code (including `Dockerfile` and `smithery.yaml`) to GitHub
2. **Deploy**: Go to [smithery.ai/new](https://smithery.ai/new) and connect your GitHub repository
3. **Verify**: Test your deployed server through the Smithery interface

Smithery will automatically build your container and host your MCP server.

## Summary

This guide showed how to migrated a Python MCP server from STDIO to HTTP transport using custom Docker containers and FastMCP. We implemented a character counter tool with proper CORS configuration, used SmitheryConfigMiddleware for configuration handling, and supported both HTTP and STDIO transport modes. This approach gives us full control over our Python environment and middleware while maintaining backward compatibility.

---

**Need help?** Join our [Discord](https://discord.gg/Afd38S5p9A) or email [support@smithery.ai](mailto:support@smithery.ai) for assistance.
