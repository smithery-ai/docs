---
title: "TypeScript with Smithery CLI"
description: "Migrate your TypeScript MCP servers from STDIO to HTTP using Smithery CLI"
---

## When to Use This Approach

Choose TypeScript with Smithery CLI when you:
- Want the simplest migration path from STDIO to HTTP
- Are using the official MCP SDK and don't need custom middleware
- Prefer automatic containerization and deployment
- Want to maintain backward compatibility with STDIO transport
- Need a fully featured interactive development playground for testing

## What We're Building

We'll build a simple MCP server with a `count_characters` tool that:
- Takes text input and counts occurrences of a specific character
- Validates an API key from Smithery configuration to demonstrate configuration handling
- Uses Smithery CLI for building the server and containerization

<Note>
**Full Implementation**: For the complete working character counter example with all dependencies and configuration files, see the [smithery-cookbook repository](https://github.com/smithery-ai/smithery-cookbook/tree/main/servers/typescript/migrate_stdio_to_http/server_with_smithery_cli).
</Note>

## Code Changes

<CodeGroup>

```typescript Before (STDIO)
// src/index.ts
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

const server = new Server({
  name: "example-server",
  version: "1.0.0"
}, {
  capabilities: { tools: {} }
});

// Add your tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return { tools: [...] };
});

// STDIO transport
const transport = new StdioServerTransport();
await server.connect(transport);
```

```typescript After (HTTP)
// src/index.ts
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// Optional: Define session configuration for server
export const configSchema = z.object({
  apiKey: z.string().describe("Your API key"), // for demonstration
});

export default function createServer({
  config,
}: {
  config: z.infer<typeof configSchema>;
}) {
  const server = new McpServer({
    name: "Character Counter",
    version: "1.0.0",
  });

  server.registerTool( "count_characters", {
    title: "Count Characters",
    description: "Count occurrences of a specific character in text",
    inputSchema: {
      text: z.string().describe("The text to search in"),
      character: z.string().describe("The character to count (single character)"),
    },
  },
    async ({ text, character }) => {
      // Verify API key is provided
      if (!config.apiKey) {
        throw new Error("API key is required");
      }
      
      // Count occurrences of the specific character (case insensitive)
      const count = text.toLowerCase().split(character.toLowerCase()).length - 1;

      return {
        content: [
          { 
            type: "text", 
            text: `The character "${character}" appears ${count} times in the text.` 
          }
        ],
      };
    }
  );

  return server.server;
}
```

</CodeGroup>

## Maintaining STDIO Compatibility (Optional)

You can maintain backward compatibility with STDIO transport while supporting HTTP through Smithery CLI. This approach allows you to:

- **Export for Smithery CLI**: The exported `createServer` function is used by Smithery CLI for HTTP deployment
- **Keep STDIO support**: The `main()` function maintains STDIO transport for local development or direct usage
- **Publish to npm**: Users can install and run your server locally with STDIO transport

Add this code to the bottom of your file for STDIO compatibility:

```typescript
async function main() {
  // Check if API key is provided
  const apiKey = process.env.API_KEY || "";
  
  // Create server with configuration
  const server = createServer({
    config: {
      apiKey,
    },
  });

  const transport = new StdioServerTransport();
  await server.connect(transport);
}

// By default the server with stdio transport
main().catch((error) => {
  console.error("Server error:", error);
  process.exit(1);
});
```

To run with STDIO transport locally (after building):

```bash
npm run build
node dist/index.js
```

When deployed with Smithery CLI, only the exported `createServer` function is used, and the `main()` function is ignored.

## Configuration Changes

### Update package.json

Configure `package.json` so Smithery CLI can find your exported server and add scripts for both HTTP and STDIO workflows:

```json
{
  "name": "my-mcp-server",
  "version": "1.0.0",
  "type": "module",
  "module": "src/index.ts", // [!code highlight]
  "scripts": {
    "dev": "npx @smithery/cli dev",
    "build": "npm run build:http",
    "build:stdio": "tsc",
    "build:http": "npx @smithery/cli build",
    "start": "npm run start:http",
    "start:http": "node .smithery/index.cjs",
    "start:stdio": "node dist/index.js",
    "prepublishOnly": "npm run build:stdio"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.17.3",
    "zod": "^3.25.46"
  }
}
```

**Important**: The `module` field tells Smithery CLI where to find your exported server function.

**Script explanations:**
- `dev`: Start development server with interactive playground
- `build`: Build for production (defaults to HTTP)
- `build:stdio`: Compile TypeScript for STDIO usage
- `build:http`: Build for Smithery HTTP deployment
- `start`: Start production server (defaults to HTTP)
- `start:http`: Run the Smithery-built HTTP server
- `start:stdio`: Run the compiled STDIO version locally
- `prepublishOnly`: Ensure STDIO build before publishing to npm

### Update smithery.yaml

<CodeGroup>

```yaml Before (STDIO)
startCommand:
  type: stdio
  commandFunction: |
    (config) => ({
      command: 'npx',
      args: ['tsx', 'src/index.ts'],
      env: {
        API_KEY: config.apiKey
      }
    })
  configSchema:
    type: object
    required: [apiKey]
    properties:
      apiKey:
        type: string
        description: Your API key
  exampleConfig:
    apiKey: "sk-example-123"
```

```yaml After (HTTP)
runtime: "typescript"
```

</CodeGroup>

That's it! The Smithery CLI handles the HTTP transport automatically.

<Note>
**No Dockerfile needed**: Unlike custom container deployments, TypeScript projects using Smithery CLI don't require a Dockerfile. The CLI handles containerization automatically.
</Note>

## Local Testing

### Using Smithery Interactive Playground

```bash
# Start development server with interactive playground
npm run dev
```

The `npm run dev` command opens the **Smithery interactive playground** where you can:
- Test your MCP server tools in real-time
- See tool responses and debug issues
- Validate your configuration schema
- Experiment with different inputs

### Building for Production

```bash
# Build your server for deployment
npm run build
```

This compiles your TypeScript code and prepares it for deployment on Smithery.

## Deployment

1. **Push Code**: Push your updated code (including updated `package.json` and `smithery.yaml`) to GitHub
2. **Deploy**: Go to [smithery.ai/new](https://smithery.ai/new) and connect your GitHub repository
3. **Verify**: Test your deployed server through the Smithery interface

The TypeScript runtime handles HTTP transport automatically - no additional configuration needed.

## Summary

This guide showed you how to build a simple TypeScript MCP server that exports a default function using the official `McpServer` from the SDK, configure session handling with Zod, and set up your `package.json` module field so Smithery CLI can find your server. This supports both HTTP deployment through Smithery CLI and optional STDIO backward compatibility, with build scripts for both workflows.

---

**Need help?** Join our [Discord](https://discord.gg/Afd38S5p9A) or email [support@smithery.ai](mailto:support@smithery.ai) for assistance.
